
###ChannelHandler
#### ChannelHandler处理流程

+ 客户端执行流程

>ChannelActive认证 ->组装实体-> 序列化 ->装载ByteBuf


+ 服务端执行流程

>ChannelRead读取数据 ->获取ByteBuf->转换Byte[]->反序列化



####ChannelHandler生命周期
[![ChannelHandler生命周期](https://c.im5i.com/2022/02/28/FPuBG.png)](https://img.sm/image/FPuBG)



####ChannelHandler性能优化
+ 使用Sharble注解
+ 交给Spring容器进行管理,在Handler类上添加Spring提供的@Component注解。Handler一般都是和底层数据库交互的,一般项目中用Spring
来管理ORM组件。
```java
//交给Spring容器管理
@Component
public class ServerLoginHandler extends ChannelInboundHandlerAdapter {
    //注入dao
    @Autowired
    private UserDao userDao;
        
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        
    }
}
@Autowired
private ServerLoginHandler serverLoginHandler;

//这里无需再创建，只需要传递实例即可
ch.pipeline().addLast(serverLoginHandler);
//参考博客 http://www.imooc.com/wiki/nettylesson/netty15.html
```

###Netty编码和解码
+ 1客户端往服务端发送消息,手工需要把实体转换成byte[],并且把byte[]写入到ByteBuf容器里面,最终转换成二进制。称为编码
+ 2服务端接收到消息,二进制是给机器去识别的,需要把二进制转换我们所熟悉的实体,整个过程就是一个解码的过程

![编码和解码](https://c.im5i.com/2022/02/28/FRA2n.png)

#####编码流程
```java
//封装编码方法
public ByteBuf encode(Object obj) {
    // 1. 创建 ByteBuf 对象
    ByteBuf byteBuf = ByteBufAllocator.DEFAULT.ioBuffer();
    // 2. 序列化 Java 对象
    byte[] bytes = SerializeUtils.serialize(obj);
    // 3. 实际编码过程
    byteBuf.writeBytes(bytes);
    return byteBuf;
}

//序列化工具类
public class SerializeUtils{
    //序列化方法
    public static byte[] serialize(Object obj){
        //省略序列化过程
        
        return null;
    }
}

```

>1创建一个ByteBuf
>
>2把内容序列化成字节数组
>
>3把字节数组写入到ByteBuf



#####解码流程
```java
//解码
public <T> T decode(ByteBuf byteBuf,Class clazz) {
    // 数据包长度
    int length = byteBuf.readableBytes();

    byte[] bytes = new byte[length];
    byteBuf.readBytes(bytes);

    return SerializeUtils.desrialize(bytes,clazz);
}

//序列化工具类
public class SerializeUtils{
    //序列化方法
    public static <T> T desrialize(byte[] bytes,Class clazz){
        //省略反序列化过程
        
        return null;
    }
}

```
>1根据ByteBuf获取可读的数据长度
>
>2根据数据长度创建相应的字节数组
>
>3把ByteBuf里面的内容读取到自定义的字节数组里面
>
>4通过反序列化的手段,把字节数组反序列化成对象





####Netty内置编解码器
StringDecoder和StringEncoder是Netty提供的对普通字符串的解码和编码器

客户端直接发送字符串

```java

ch.pipeline().addLast(new StringEncoder());
ch.pipeline().addLast(new StringDecoder());
ch.pipeline().addLast(new ClientTestHandler());

public class ClientTestHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
		//客户端直接写字符串，没有任何的数据加工
        ctx.channel().writeAndFlush("hello world");
    }
}

```

服务端直接强转字符串
```java
ch.pipeline().addLast(new StringEncoder());
ch.pipeline().addLast(new StringDecoder());
ch.pipeline().addLast(new ServerTestHandler());

public class ServerTestHandler extends ChannelInboundHandlerAdapter {
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
		//直接把msg转换成String类型
        String str=msg.toString();
        System.out.println("str="+str);
    }
}

```
![Netty自带编解码器.png](https://c.im5i.com/2022/02/28/FRECv.png)


流程说明
>StringDecoder 必须放在业务 Handler 之前，因为都是 InboundHandler，需要按顺序执行；
>
>StringEncoder 放在业务 Handler 之前，则可以使用 ctx.writeAndFlush () 输出数据，也可以使用 ctx.channel ().writeAndFlus () 输出数据（ChannelHandler 已经讲过原理了）；
>
>StringEncoder 放在业务 Handler 之后，则只能使用 ctx.channel().writeAndFlush() 输出数据。


参考:http://www.imooc.com/wiki/nettylesson/netty14.html